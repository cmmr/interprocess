[{"path":"https://cmmr.github.io/interprocess/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 interprocess authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmmr.github.io/interprocess/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel P. Smith. Author, maintainer. Alkek Center Metagenomics Microbiome Research. Copyright holder, funder.","code":""},{"path":"https://cmmr.github.io/interprocess/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith D (2025). interprocess: Mutexes, Semaphores, Message Queues. R package version 1.1.2, https://cmmr.github.io/interprocess/.","code":"@Manual{,   title = {interprocess: Mutexes, Semaphores, and Message Queues},   author = {Daniel P. Smith},   year = {2025},   note = {R package version 1.1.2},   url = {https://cmmr.github.io/interprocess/}, }"},{"path":"https://cmmr.github.io/interprocess/index.html","id":"interprocess","dir":"","previous_headings":"","what":"Mutexes, Semaphores, and Message Queues","title":"Mutexes, Semaphores, and Message Queues","text":"goal interprocess synchronize concurrent R processes. Allows R access low-level operating system mechanisms performing atomic operations shared data structures. Mutexes provide shared exclusive locks. Semaphores act counters. Message queues move text strings one process another. interprocess communication (IPC) tools can optionally block without timeout. Works cross-platform, including Windows, MacOS, Linux, can used synchronize mixture R sessions types processes needed. Implemented using Boost C++ library.","code":""},{"path":"https://cmmr.github.io/interprocess/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Mutexes, Semaphores, and Message Queues","text":"","code":"# Install the latest stable version from CRAN: install.packages(\"interprocess\")  # Or the development version from GitHub: install.packages(\"pak\") pak::pak(\"cmmr/interprocess\")"},{"path":"https://cmmr.github.io/interprocess/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Mutexes, Semaphores, and Message Queues","text":"Mutexes, semaphores, message queues managed operating system. process knows resource’s name can access . Therefore, sharing resource name (short text string) amongst cooperating processes enables communication synchronization. names can alphanumeric string starts letter longer 250 characters. mutex(), semaphore(), queue() functions default generating unique identifier, can provide custom pre-existing one name parameter. resource associated specific file directory, file parameter can used derive name normalizing hashing path. Setting cleanup = TRUE automatically remove resource R session exits. Otherwise, resource persist $remove() called operating system restarted.","code":""},{"path":"https://cmmr.github.io/interprocess/index.html","id":"mutexes","dir":"","previous_headings":"Usage","what":"Mutexes","title":"Mutexes, Semaphores, and Message Queues","text":"exclusive lock acquired default. shared lock, use shared = TRUE.","code":"tmp <- tempfile() mut <- interprocess::mutex(file = tmp)  mut$name #> [1] \"oThd9KRpHb0\"  with(mut, writeLines('Important Data', tmp))  with(mut, shared = TRUE, readLines(tmp)) #> [1] \"Important Data\"  mut$remove() unlink(tmp)"},{"path":"https://cmmr.github.io/interprocess/index.html","id":"semaphores","dir":"","previous_headings":"Usage","what":"Semaphores","title":"Mutexes, Semaphores, and Message Queues","text":"semaphore’s value can incremented $post() decremented $wait(). initial value can also set constructor.","code":"sem <- interprocess::semaphore('mySemaphore', value = 1)  sem$name #> [1] \"mySemaphore\"  sem$post()  sem$wait(timeout_ms = 0) #> [1] TRUE  sem$wait(timeout_ms = 0) #> [1] TRUE  sem$wait(timeout_ms = 0) #> [1] FALSE  sem$remove()"},{"path":"https://cmmr.github.io/interprocess/index.html","id":"message-queues","dir":"","previous_headings":"Usage","what":"Message Queues","title":"Mutexes, Semaphores, and Message Queues","text":"constructor’s max_count max_nchar parameters determine much memory allocated queue.","code":"mq <- interprocess::queue(max_count = 2, max_nchar = 5)  mq$name #> [1] \"Ae2udeRLWcb\"  mq$send('Hello') mq$send('Hi', priority = 1)  mq$receive(timeout_ms = 0) #> [1] \"Hi\"  mq$receive(timeout_ms = 0) #> [1] \"Hello\"  mq$receive(timeout_ms = 0) #> [1] NULL  mq$remove()"},{"path":"https://cmmr.github.io/interprocess/reference/mutex.html","id":null,"dir":"Reference","previous_headings":"","what":"Shared and Exclusive Locks — mutex","title":"Shared and Exclusive Locks — mutex","text":"Mutually exclusive (mutex) locks used control access shared resources. exclusive lock grants permission one process time, example update contents database file. exclusive lock active, exclusive shared locks granted. Multiple shared locks can held different processes time, example read database file. shared lock active, exclusive locks granted.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/mutex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shared and Exclusive Locks — mutex","text":"","code":"mutex(name = uid(\"M\"), assert = NULL, cleanup = FALSE, file = NULL)  # S3 method for class 'mutex' with(data, expr, alt_expr = NULL, shared = FALSE, timeout_ms = Inf, ...)"},{"path":"https://cmmr.github.io/interprocess/reference/mutex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shared and Exclusive Locks — mutex","text":"name Unique ID. Alphanumeric, starting letter. assert Apply additional constraint. 'create' - Error mutex already exists. 'exists' - Error mutex exist. NULL - constraint; create mutex exist. cleanup Remove mutex R session exits. FALSE, mutex persist $remove() called operating system restarted. file Use hash file/directory path mutex name. file read modified, need exist. data mutex object. expr Expression evaluate mutex acquired. alt_expr Expression evaluate timeout_ms reached. shared FALSE (default) exclusive lock returned. TRUE, shared lock returned instead. See description. timeout_ms Maximum time (milliseconds) block process waiting operation succeed. Use 0 Inf return immediately successful, respectively. ... used.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/mutex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shared and Exclusive Locks — mutex","text":"mutex() returns mutex object following methods: $name Returns mutex's name (scalar character). $lock(shared = FALSE, timeout_ms = Inf) Returns TRUE lock acquired, FALSE timeout reached. $unlock(warn = TRUE) Returns TRUE successful, FALSE (optional warning) mutex locked. $remove() Returns TRUE success, FALSE mutex found. () returns eval(expr) lock acquired, eval(alt_expr) timeout reached.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/mutex.html","id":"error-handling","dir":"Reference","previous_headings":"","what":"Error Handling","title":"Shared and Exclusive Locks — mutex","text":"() wrapper automatically unlocks mutex error stops evaluation expr. directly calling lock(), sure unlock() registered error handlers added .exit(). Otherwise, lock persist process terminates.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/mutex.html","id":"duplicate-mutexes","dir":"Reference","previous_headings":"","what":"Duplicate Mutexes","title":"Shared and Exclusive Locks — mutex","text":"Mutex locks per-process. process already lock, can attempt acquire second lock mutex.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/mutex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shared and Exclusive Locks — mutex","text":"","code":"tmp <- tempfile() mut <- interprocess::mutex(file = tmp)  print(mut) #> <mutex> \"f6CMgnZFLQq\"  # Exclusive lock to write the file with(mut, writeLines('some data', tmp))  # Use a shared lock to read the file with(mut,   shared     = TRUE,   timeout_ms = 0,    expr       = readLines(tmp),    alt_expr   = warning('Mutex was locked. Giving up.') ) #> [1] \"some data\"  # Directly lock/unlock with safeguards if (mut$lock(timeout_ms = 0)) {   local({     on.exit(mut$unlock())     writeLines('more data', tmp)   }) } else {   warning('Mutex was locked. Giving up.') }  mut$remove() unlink(tmp)"},{"path":"https://cmmr.github.io/interprocess/reference/queue.html","id":null,"dir":"Reference","previous_headings":"","what":"Send Text Messages Between Processes — queue","title":"Send Text Messages Between Processes — queue","text":"interprocess queue ensures message delivered one reader, time message removed queue. Ideal producer/consumer situations message defines work waiting processed. message can scalar character, example, JSON string, path RDS file, simple command like 'exit'.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/queue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Send Text Messages Between Processes — queue","text":"","code":"queue(   name = uid(\"Q\"),   assert = NULL,   max_count = 100,   max_nchar = 128,   cleanup = FALSE,   file = NULL )  # S3 method for class 'queue' with(data, expr, alt_expr = NULL, timeout_ms = Inf, ...)"},{"path":"https://cmmr.github.io/interprocess/reference/queue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Send Text Messages Between Processes — queue","text":"name Unique ID. Alphanumeric, starting letter. assert Apply additional constraint. 'create' - Error queue already exists. 'exists' - Error queue exist. NULL - constraint; create queue exist. max_count maximum number messages can stored queue time. Attempting send additional messages cause send() block return FALSE. Ignored queue already exists. max_nchar maximum number characters message. Attempting send larger messages throw error. Ignored queue already exists. cleanup Remove queue R session exits. FALSE, queue persist $remove() called operating system restarted. file Use hash file/directory path queue name. file read modified, need exist. data queue object. expr Expression evaluate message received. message can accessed . context. See examples. alt_expr Expression evaluate timeout_ms reached. timeout_ms Maximum time (milliseconds) block process waiting operation succeed. Use 0 Inf return immediately successful, respectively. ... used.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/queue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Send Text Messages Between Processes — queue","text":"queue() returns queue object following methods: $name Returns message queue's name (scalar character). $send(msg, timeout_ms = Inf, priority = 0) Returns TRUE success, FALSE timeout reached. msg: message (scalar character) add message queue. priority: Higher priority messages retrieved queue first. 0 = lowest priority; integers . $receive(timeout_ms = Inf) Returns next message queue, NULL timeout reached. $count() Returns number messages currently queue (scalar integer). $max_count() Returns maximum number messages queue can hold (scalar integer). $max_nchar() Returns maximum number characters per message (scalar integer). $remove() Returns TRUE success, FALSE error. () returns eval(expr) success; eval(alt_expr) otherwise.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/queue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Send Text Messages Between Processes — queue","text":"","code":"mq <- interprocess::queue() print(mq) #> <queue> \"Ab08deRL3b3\"  mq$send(paste('my favorite number is', floor(runif(1) * 100))) mq$count() #> [1] 1  mq$receive() #> [1] \"my favorite number is 8\" mq$receive(timeout_ms = 0) #> NULL  mq$send('The Matrix has you...') with(mq, paste('got message:', .), 'no messages', timeout_ms = 0) #> [1] \"got message: The Matrix has you...\" with(mq, paste('got message:', .), 'no messages', timeout_ms = 0) #> [1] \"no messages\"  mq$remove()"},{"path":"https://cmmr.github.io/interprocess/reference/semaphore.html","id":null,"dir":"Reference","previous_headings":"","what":"Increment and Decrement an Integer — semaphore","title":"Increment and Decrement an Integer — semaphore","text":"semaphore integer operating system keeps track . process knows semaphore's identifier can increment decrement value, though decremented zero. semaphore zero, calling $wait(timeout_ms = 0) return FALSE whereas $wait(timeout_ms = Inf) block semaphore incremented another process. multiple processes blocked, single call $post() unblock one blocked processes. possible wait specific amount time, example, $wait(timeout_ms = 10000) wait 10 seconds. semaphore incremented within 10 seconds, function immediately return TRUE. Otherwise return FALSE 10 second mark.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/semaphore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Increment and Decrement an Integer — semaphore","text":"","code":"semaphore(   name = uid(\"S\"),   assert = NULL,   value = 0,   cleanup = FALSE,   file = NULL )  # S3 method for class 'semaphore' with(data, expr, alt_expr = NULL, timeout_ms = Inf, ...)"},{"path":"https://cmmr.github.io/interprocess/reference/semaphore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Increment and Decrement an Integer — semaphore","text":"name Unique ID. Alphanumeric, starting letter. assert Apply additional constraint. 'create' - Error semaphore already exists. 'exists' - Error semaphore exist. NULL - constraint; create semaphore exist. value initial value semaphore. cleanup Remove semaphore R session exits. FALSE, semaphore persist $remove() called operating system restarted. file Use hash file/directory path semaphore name. file read modified, need exist. data semaphore object. expr Expression evaluate semaphore posted. alt_expr Expression evaluate timeout_ms reached. timeout_ms Maximum time (milliseconds) block process waiting operation succeed. Use 0 Inf return immediately successful, respectively. ... used.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/semaphore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Increment and Decrement an Integer — semaphore","text":"semaphore() returns semaphore object following methods: $name Returns semaphore's name (scalar character). $post() Returns TRUE increment successful, FALSE error. $wait(timeout_ms = Inf) Returns TRUE decrement successful, FALSE timeout reached. $remove() Returns TRUE success, FALSE error. () returns eval(expr) success, eval(alt_expr) timeout reached.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/semaphore.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Increment and Decrement an Integer — semaphore","text":"","code":"sem <- interprocess::semaphore() print(sem) #> <semaphore> \"Ab08deRL3b4\"  sem$post() sem$wait(timeout_ms = 0) #> [1] TRUE sem$wait(timeout_ms = 0) #> [1] FALSE  sem$post() with(sem, 'success', 'timed out', timeout_ms = 0) #> [1] \"success\" with(sem, 'success', 'timed out', timeout_ms = 0) #> [1] \"timed out\"  sem$remove()"},{"path":"https://cmmr.github.io/interprocess/reference/uid.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Names — uid","title":"Generate Names — uid","text":"ensure broad compatibility across different operating systems, names mutexes, semaphores, message queues start letter followed 249 alphanumeric characters. functions generate names meeting requirements. uid(): 11-character encoding PID time since epoch. hash(): 11-character hash string (hash space = 2^64).","code":""},{"path":"https://cmmr.github.io/interprocess/reference/uid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Names — uid","text":"","code":"uid()  hash(str)"},{"path":"https://cmmr.github.io/interprocess/reference/uid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Names — uid","text":"str string (scalar character).","code":""},{"path":"https://cmmr.github.io/interprocess/reference/uid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Names — uid","text":"string (scalar character) can used mutex, semaphore, message queue name.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/uid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Names — uid","text":"uid()s encode sequential 1/100 second intervals, beginning current process's start time. number requested UIDs exceeds number 1/100 seconds process alive, process momentarily sleep returning. uid()s begin - R'; hash()s begin - v.","code":""},{"path":"https://cmmr.github.io/interprocess/reference/uid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Names — uid","text":"","code":"library(interprocess)          uid() #> [1] \"Ab08deRL3b5\"          hash('192.168.1.123:8011') #> [1] \"mGUrcriGUSA\""},{"path":"https://cmmr.github.io/interprocess/news/index.html","id":"interprocess-110","dir":"Changelog","previous_headings":"","what":"interprocess 1.1.0","title":"interprocess 1.1.0","text":"CRAN release: 2025-05-09 Changed length uid() hash() 12 characters.","code":""},{"path":"https://cmmr.github.io/interprocess/news/index.html","id":"interprocess-100","dir":"Changelog","previous_headings":"","what":"interprocess 1.0.0","title":"interprocess 1.0.0","text":"CRAN release: 2025-05-02 Initial CRAN submission.","code":""}]
